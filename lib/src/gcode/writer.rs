//! G-code writer.
//!
//! This module provides the GCodeWriter type for building G-code output,
//! mirroring BambuStudio's GCodeWriter class.

use crate::config::PrintConfig;
use crate::gcode::{ArcDirection, GCode, GCodeCommand, GCodeStats};
use crate::geometry::PointF;
use crate::CoordF;
use std::fmt;

/// A writer for building G-code output.
///
/// GCodeWriter maintains state about the current position, extrusion,
/// and other parameters, and provides methods for generating G-code
/// commands while tracking this state.
pub struct GCodeWriter {
    /// The G-code being built.
    gcode: GCode,

    /// Current X position (mm).
    x: CoordF,

    /// Current Y position (mm).
    y: CoordF,

    /// Current Z position (mm).
    z: CoordF,

    /// Current E (extrusion) position (mm).
    e: CoordF,

    /// Current feedrate (mm/min).
    feedrate: CoordF,

    /// Whether we're in absolute positioning mode.
    absolute_positioning: bool,

    /// Whether we're in absolute extrusion mode.
    absolute_extrusion: bool,

    /// Current extruder index.
    extruder: usize,

    /// Whether position is known.
    position_known: bool,

    /// Current layer index.
    layer_index: usize,

    /// Current layer Z height.
    layer_z: CoordF,

    /// Retraction state.
    retracted: bool,

    /// Retraction length used.
    retraction_length: CoordF,

    /// Z lift during retraction.
    retract_lift: CoordF,

    /// Z before lift.
    z_before_lift: CoordF,

    /// Statistics being collected.
    stats: GCodeStats,

    /// Configuration reference.
    config: PrintConfig,
}

impl GCodeWriter {
    /// Create a new GCodeWriter with default configuration.
    pub fn new() -> Self {
        Self::with_config(PrintConfig::default())
    }

    /// Create a new GCodeWriter with the given configuration.
    pub fn with_config(config: PrintConfig) -> Self {
        Self {
            gcode: GCode::new(),
            x: 0.0,
            y: 0.0,
            z: 0.0,
            e: 0.0,
            feedrate: 0.0,
            absolute_positioning: true,
            absolute_extrusion: true,
            extruder: 0,
            position_known: false,
            layer_index: 0,
            layer_z: 0.0,
            retracted: false,
            retraction_length: config.retract_length,
            retract_lift: config.retract_lift,
            z_before_lift: 0.0,
            stats: GCodeStats::default(),
            config,
        }
    }

    /// Get the built G-code.
    pub fn gcode(&self) -> &GCode {
        &self.gcode
    }

    /// Consume the writer and return the built G-code.
    pub fn finish(mut self) -> GCode {
        self.gcode.stats = self.stats;
        self.gcode
    }

    /// Get the current position.
    pub fn position(&self) -> PointF {
        PointF::new(self.x, self.y)
    }

    /// Get the current Z position.
    pub fn z(&self) -> CoordF {
        self.z
    }

    /// Get the current E position.
    pub fn e(&self) -> CoordF {
        self.e
    }

    /// Get the current feedrate.
    pub fn feedrate(&self) -> CoordF {
        self.feedrate
    }

    /// Check if position is known.
    pub fn is_position_known(&self) -> bool {
        self.position_known
    }

    /// Check if currently retracted.
    pub fn is_retracted(&self) -> bool {
        self.retracted
    }

    /// Get the current layer index.
    pub fn layer_index(&self) -> usize {
        self.layer_index
    }

    /// Get the statistics.
    pub fn stats(&self) -> &GCodeStats {
        &self.stats
    }

    // === G-code generation methods ===

    /// Write a raw G-code line.
    pub fn write_raw(&mut self, line: &str) {
        self.gcode.append_line(line);
    }

    /// Write a comment.
    pub fn write_comment(&mut self, comment: &str) {
        self.gcode.append_comment(comment);
    }

    /// Write a G-code command.
    pub fn write_command(&mut self, cmd: &GCodeCommand) {
        self.gcode.append_line(&cmd.to_gcode());
    }

    /// Write the preamble (start G-code).
    pub fn write_preamble(&mut self) {
        self.write_comment("Generated by Slicer");
        self.write_comment("");

        // Set absolute positioning
        self.write_command(&GCodeCommand::AbsolutePositioning);
        self.absolute_positioning = true;

        // Set extrusion mode based on config (M82 = absolute, M83 = relative)
        if self.config.use_relative_e {
            self.write_command(&GCodeCommand::RelativeExtrusion);
            self.absolute_extrusion = false;
        } else {
            self.write_command(&GCodeCommand::AbsoluteExtrusion);
            self.absolute_extrusion = true;
        }

        // Reset extruder position
        self.write_command(&GCodeCommand::SetPosition {
            x: None,
            y: None,
            z: None,
            e: Some(0.0),
        });
        self.e = 0.0;
    }

    /// Write the end G-code.
    pub fn write_end(&mut self) {
        self.write_comment("End G-code");

        // Turn off heaters
        self.write_command(&GCodeCommand::SetExtruderTemp { s: 0 });
        self.write_command(&GCodeCommand::SetBedTemp { s: 0 });

        // Turn off fan
        self.write_command(&GCodeCommand::FanOff);

        // Home X and Y
        self.write_command(&GCodeCommand::Home {
            x: true,
            y: true,
            z: false,
        });
    }

    /// Set the bed temperature.
    pub fn set_bed_temperature(&mut self, temp: u32, wait: bool) {
        if wait {
            self.write_command(&GCodeCommand::SetBedTempWait { s: temp });
        } else {
            self.write_command(&GCodeCommand::SetBedTemp { s: temp });
        }
    }

    /// Set the extruder temperature.
    pub fn set_extruder_temperature(&mut self, temp: u32, wait: bool) {
        if wait {
            self.write_command(&GCodeCommand::SetExtruderTempWait { s: temp });
        } else {
            self.write_command(&GCodeCommand::SetExtruderTemp { s: temp });
        }
    }

    /// Set the fan speed (0-255).
    pub fn set_fan_speed(&mut self, speed: u32) {
        if speed > 0 {
            self.write_command(&GCodeCommand::SetFanSpeed { s: speed });
        } else {
            self.write_command(&GCodeCommand::FanOff);
        }
    }

    /// Home the printer.
    pub fn home(&mut self, x: bool, y: bool, z: bool) {
        self.write_command(&GCodeCommand::Home { x, y, z });
        if x {
            self.x = 0.0;
        }
        if y {
            self.y = 0.0;
        }
        if z {
            self.z = 0.0;
        }
        self.position_known = true;
    }

    /// Travel move (no extrusion).
    pub fn travel_to(&mut self, x: CoordF, y: CoordF, feedrate: Option<CoordF>) {
        let f = feedrate.unwrap_or(self.config.travel_speed * 60.0);

        // Track travel distance
        let dx = x - self.x;
        let dy = y - self.y;
        self.stats.travel_distance_mm += (dx * dx + dy * dy).sqrt();

        self.write_command(&GCodeCommand::RapidMove {
            x: Some(x),
            y: Some(y),
            z: None,
            f: if (f - self.feedrate).abs() > 0.01 {
                Some(f)
            } else {
                None
            },
        });

        self.x = x;
        self.y = y;
        self.feedrate = f;
        self.position_known = true;
    }

    /// Travel move to a specific Z height.
    pub fn travel_to_z(&mut self, z: CoordF, feedrate: Option<CoordF>) {
        let f = feedrate.unwrap_or(self.config.travel_speed * 60.0);

        self.write_command(&GCodeCommand::RapidMove {
            x: None,
            y: None,
            z: Some(z),
            f: if (f - self.feedrate).abs() > 0.01 {
                Some(f)
            } else {
                None
            },
        });

        self.z = z;
        self.feedrate = f;
    }

    /// Extrusion move.
    ///
    /// In absolute E mode: `e` is the target absolute E position.
    /// In relative E mode: `e` is treated as absolute internally and converted
    /// to relative (delta) for output. This allows the pipeline to always pass
    /// absolute E values and let the writer handle the conversion.
    pub fn extrude_to(&mut self, x: CoordF, y: CoordF, e: CoordF, feedrate: Option<CoordF>) {
        let f = feedrate.unwrap_or(self.config.print_speed * 60.0);

        // Calculate the extrusion delta
        let de = e - self.e;
        self.stats.extrusion_distance_mm += de.abs();

        // Track travel distance
        let dx = x - self.x;
        let dy = y - self.y;
        self.stats.travel_distance_mm += (dx * dx + dy * dy).sqrt();

        // Output E value depends on extrusion mode
        let e_out = if self.absolute_extrusion {
            e // Absolute: output the target E position
        } else {
            de // Relative: output the delta
        };

        self.write_command(&GCodeCommand::LinearMove {
            x: Some(x),
            y: Some(y),
            z: None,
            e: Some(e_out),
            f: if (f - self.feedrate).abs() > 0.01 {
                Some(f)
            } else {
                None
            },
        });

        self.x = x;
        self.y = y;
        self.e = e; // Always track absolute E internally
        self.feedrate = f;
        self.position_known = true;
    }

    /// Arc extrusion move (G2/G3).
    ///
    /// Extrudes along a circular arc from the current position to (x, y).
    /// The arc center is specified relative to the current position using i, j offsets.
    ///
    /// # Arguments
    /// * `x` - Target X position
    /// * `y` - Target Y position
    /// * `i` - X offset from current position to arc center
    /// * `j` - Y offset from current position to arc center
    /// * `e` - Target extrusion position (absolute or relative depending on mode)
    /// * `direction` - Arc direction (Clockwise = G2, CounterClockwise = G3)
    /// * `feedrate` - Optional feedrate override (mm/min)
    pub fn extrude_arc(
        &mut self,
        x: CoordF,
        y: CoordF,
        i: CoordF,
        j: CoordF,
        e: CoordF,
        direction: ArcDirection,
        feedrate: Option<CoordF>,
    ) {
        let f = feedrate.unwrap_or(self.config.print_speed * 60.0);

        // Calculate the extrusion delta
        let de = e - self.e;
        self.stats.extrusion_distance_mm += de.abs();

        // Calculate arc length for travel distance tracking
        // Use the arc center to calculate radius and approximate arc length
        let center_x = self.x + i;
        let center_y = self.y + j;
        let radius = (i * i + j * j).sqrt();

        // Calculate start and end angles
        let start_angle = (self.y - center_y).atan2(self.x - center_x);
        let end_angle = (y - center_y).atan2(x - center_x);

        // Calculate arc angle based on direction
        let mut arc_angle = end_angle - start_angle;
        match direction {
            ArcDirection::CounterClockwise => {
                if arc_angle < 0.0 {
                    arc_angle += 2.0 * std::f64::consts::PI;
                }
            }
            ArcDirection::Clockwise => {
                if arc_angle > 0.0 {
                    arc_angle -= 2.0 * std::f64::consts::PI;
                }
            }
        }

        let arc_length = radius * arc_angle.abs();
        self.stats.travel_distance_mm += arc_length;

        // Output E value depends on extrusion mode
        let e_out = if self.absolute_extrusion {
            e // Absolute: output the target E position
        } else {
            de // Relative: output the delta
        };

        // Write the appropriate arc command
        let cmd = match direction {
            ArcDirection::Clockwise => GCodeCommand::ArcCW {
                x,
                y,
                i,
                j,
                e: Some(e_out),
                f: if (f - self.feedrate).abs() > 0.01 {
                    Some(f)
                } else {
                    None
                },
            },
            ArcDirection::CounterClockwise => GCodeCommand::ArcCCW {
                x,
                y,
                i,
                j,
                e: Some(e_out),
                f: if (f - self.feedrate).abs() > 0.01 {
                    Some(f)
                } else {
                    None
                },
            },
        };

        self.write_command(&cmd);

        self.x = x;
        self.y = y;
        self.e = e; // Always track absolute E internally
        self.feedrate = f;
        self.position_known = true;
    }

    /// Arc extrusion move clockwise (G2).
    pub fn extrude_arc_cw(
        &mut self,
        x: CoordF,
        y: CoordF,
        i: CoordF,
        j: CoordF,
        e: CoordF,
        feedrate: Option<CoordF>,
    ) {
        self.extrude_arc(x, y, i, j, e, ArcDirection::Clockwise, feedrate);
    }

    /// Arc extrusion move counter-clockwise (G3).
    pub fn extrude_arc_ccw(
        &mut self,
        x: CoordF,
        y: CoordF,
        i: CoordF,
        j: CoordF,
        e: CoordF,
        feedrate: Option<CoordF>,
    ) {
        self.extrude_arc(x, y, i, j, e, ArcDirection::CounterClockwise, feedrate);
    }

    /// Retract filament.
    pub fn retract(&mut self) {
        if self.retracted {
            return;
        }

        let retract_speed = self.config.retract_speed * 60.0;
        let new_e = if self.absolute_extrusion {
            self.e - self.retraction_length
        } else {
            -self.retraction_length
        };

        self.write_command(&GCodeCommand::LinearMove {
            x: None,
            y: None,
            z: None,
            e: Some(new_e),
            f: Some(retract_speed),
        });

        if self.absolute_extrusion {
            self.e = new_e;
        }

        // Z lift
        if self.retract_lift > 0.0 {
            self.z_before_lift = self.z;
            self.travel_to_z(self.z + self.retract_lift, None);
        }

        self.retracted = true;
        self.stats.retraction_count += 1;
    }

    /// Unretract (restore) filament.
    pub fn unretract(&mut self) {
        if !self.retracted {
            return;
        }

        // Z unlift
        if self.retract_lift > 0.0 && self.z > self.z_before_lift {
            self.travel_to_z(self.z_before_lift, None);
        }

        let retract_speed = self.config.retract_speed * 60.0;
        let new_e = if self.absolute_extrusion {
            self.e + self.retraction_length
        } else {
            self.retraction_length
        };

        self.write_command(&GCodeCommand::LinearMove {
            x: None,
            y: None,
            z: None,
            e: Some(new_e),
            f: Some(retract_speed),
        });

        if self.absolute_extrusion {
            self.e = new_e;
        }

        self.retracted = false;
    }

    /// Start a new layer.
    pub fn start_layer(&mut self, layer_index: usize, z: CoordF) {
        self.layer_index = layer_index;
        self.layer_z = z;
        self.stats.layer_count = layer_index + 1;

        self.write_comment(&format!("Layer {}, Z = {:.3}", layer_index, z));

        // Move to layer Z
        if (self.z - z).abs() > 0.001 {
            self.travel_to_z(z, None);
        }
    }

    /// Reset the extruder position.
    pub fn reset_e(&mut self) {
        self.write_command(&GCodeCommand::SetPosition {
            x: None,
            y: None,
            z: None,
            e: Some(0.0),
        });
        self.e = 0.0;
    }

    /// Set absolute positioning mode.
    pub fn set_absolute_positioning(&mut self, absolute: bool) {
        if absolute != self.absolute_positioning {
            if absolute {
                self.write_command(&GCodeCommand::AbsolutePositioning);
            } else {
                self.write_command(&GCodeCommand::RelativePositioning);
            }
            self.absolute_positioning = absolute;
        }
    }

    /// Set absolute extrusion mode.
    pub fn set_absolute_extrusion(&mut self, absolute: bool) {
        if absolute != self.absolute_extrusion {
            if absolute {
                self.write_command(&GCodeCommand::AbsoluteExtrusion);
            } else {
                self.write_command(&GCodeCommand::RelativeExtrusion);
            }
            self.absolute_extrusion = absolute;
        }
    }
}

impl Default for GCodeWriter {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Debug for GCodeWriter {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "GCodeWriter(pos=({:.3}, {:.3}, {:.3}), e={:.3}, layer={})",
            self.x, self.y, self.z, self.e, self.layer_index
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_writer_new() {
        let writer = GCodeWriter::new();
        assert!(!writer.is_position_known());
        assert!(!writer.is_retracted());
        assert_eq!(writer.layer_index(), 0);
    }

    #[test]
    fn test_writer_preamble_relative_e() {
        // Default config uses relative E mode (M83)
        let mut writer = GCodeWriter::new();
        writer.write_preamble();

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G90")); // Absolute positioning
        assert!(gcode.content().contains("M83")); // Relative extrusion (default)
        assert!(gcode.content().contains("G92")); // Reset E
    }

    #[test]
    fn test_writer_preamble_absolute_e() {
        // Test absolute E mode (M82)
        let mut config = PrintConfig::default();
        config.use_relative_e = false;
        let mut writer = GCodeWriter::with_config(config);
        writer.write_preamble();

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G90")); // Absolute positioning
        assert!(gcode.content().contains("M82")); // Absolute extrusion
        assert!(gcode.content().contains("G92")); // Reset E
    }

    #[test]
    fn test_writer_travel() {
        let mut writer = GCodeWriter::new();
        writer.travel_to(10.0, 20.0, None);

        assert!(writer.is_position_known());
        assert!((writer.position().x - 10.0).abs() < 1e-6);
        assert!((writer.position().y - 20.0).abs() < 1e-6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G0"));
        assert!(gcode.content().contains("X10.000"));
        assert!(gcode.content().contains("Y20.000"));
    }

    #[test]
    fn test_writer_extrude_relative_e() {
        // Default is relative E mode (M83)
        let mut writer = GCodeWriter::new();
        writer.write_preamble(); // Sets up relative E mode

        // First extrusion: from E=0 to E=1.0, so relative output is 1.0
        writer.extrude_to(10.0, 10.0, 1.0, None);
        assert!((writer.e() - 1.0).abs() < 1e-6);

        // Second extrusion: from E=1.0 to E=2.5, so relative output is 1.5
        writer.extrude_to(20.0, 20.0, 2.5, None);
        assert!((writer.e() - 2.5).abs() < 1e-6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G1"));
        // In relative mode, E values are deltas
        assert!(gcode.content().contains("E1.00000")); // First move
        assert!(gcode.content().contains("E1.50000")); // Second move (delta)
    }

    #[test]
    fn test_writer_extrude_absolute_e() {
        // Test absolute E mode (M82)
        let mut config = PrintConfig::default();
        config.use_relative_e = false;
        let mut writer = GCodeWriter::with_config(config);
        writer.write_preamble();

        writer.extrude_to(10.0, 10.0, 1.0, None);
        assert!((writer.e() - 1.0).abs() < 1e-6);

        writer.extrude_to(20.0, 20.0, 2.5, None);
        assert!((writer.e() - 2.5).abs() < 1e-6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G1"));
        // In absolute mode, E values are absolute positions
        assert!(gcode.content().contains("E1.00000"));
        assert!(gcode.content().contains("E2.50000"));
    }

    #[test]
    fn test_writer_retract() {
        let mut writer = GCodeWriter::new();
        assert!(!writer.is_retracted());

        writer.retract();
        assert!(writer.is_retracted());

        // Retract again should be no-op
        let len_before = writer.gcode().len();
        writer.retract();
        let len_after = writer.gcode().len();
        assert_eq!(len_before, len_after);

        writer.unretract();
        assert!(!writer.is_retracted());
    }

    #[test]
    fn test_writer_start_layer() {
        let mut writer = GCodeWriter::new();
        writer.start_layer(5, 1.0);

        assert_eq!(writer.layer_index(), 5);
        assert_eq!(writer.stats().layer_count, 6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("Layer 5"));
    }

    #[test]
    fn test_writer_temperatures() {
        let mut writer = GCodeWriter::new();
        writer.set_bed_temperature(60, false);
        writer.set_extruder_temperature(200, true);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("M140 S60"));
        assert!(gcode.content().contains("M109 S200"));
    }

    #[test]
    fn test_writer_fan() {
        let mut writer = GCodeWriter::new();
        writer.set_fan_speed(255);
        writer.set_fan_speed(0);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("M106 S255"));
        assert!(gcode.content().contains("M107"));
    }

    #[test]
    fn test_writer_home() {
        let mut writer = GCodeWriter::new();
        writer.home(true, true, true);

        assert!(writer.is_position_known());
        assert!((writer.position().x).abs() < 1e-6);
        assert!((writer.position().y).abs() < 1e-6);
        assert!((writer.z()).abs() < 1e-6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G28"));
    }

    #[test]
    fn test_writer_finish() {
        let mut writer = GCodeWriter::new();
        writer.write_preamble();
        writer.start_layer(0, 0.3);
        writer.extrude_to(10.0, 10.0, 1.0, None);

        let gcode = writer.finish();
        assert!(gcode.stats.layer_count > 0);
        assert!(gcode.stats.extrusion_distance_mm > 0.0);
    }

    #[test]
    fn test_writer_stats_tracking() {
        let mut writer = GCodeWriter::new();

        // Travel
        writer.travel_to(100.0, 0.0, None);
        assert!((writer.stats().travel_distance_mm - 100.0).abs() < 1e-6);

        // Extrusion
        writer.extrude_to(100.0, 100.0, 10.0, None);
        assert!((writer.stats().extrusion_distance_mm - 10.0).abs() < 1e-6);

        // Retraction
        writer.retract();
        assert_eq!(writer.stats().retraction_count, 1);
    }

    #[test]
    fn test_writer_arc_cw() {
        let mut writer = GCodeWriter::new();
        writer.travel_to(10.0, 0.0, None);

        // Arc from (10, 0) to (0, 10) with center at (0, 0)
        // I = 0 - 10 = -10, J = 0 - 0 = 0
        writer.extrude_arc_cw(0.0, 10.0, -10.0, 0.0, 1.0, Some(1200.0));

        assert!((writer.position().x - 0.0).abs() < 1e-6);
        assert!((writer.position().y - 10.0).abs() < 1e-6);
        assert!((writer.e() - 1.0).abs() < 1e-6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G2"));
        assert!(gcode.content().contains("I-10.000"));
        assert!(gcode.content().contains("J0.000"));
    }

    #[test]
    fn test_writer_arc_ccw() {
        let mut writer = GCodeWriter::new();
        writer.travel_to(10.0, 0.0, None);

        // Arc from (10, 0) to (0, 10) with center at (0, 0)
        writer.extrude_arc_ccw(0.0, 10.0, -10.0, 0.0, 1.0, Some(1200.0));

        assert!((writer.position().x - 0.0).abs() < 1e-6);
        assert!((writer.position().y - 10.0).abs() < 1e-6);

        let gcode = writer.gcode();
        assert!(gcode.content().contains("G3"));
    }

    #[test]
    fn test_writer_arc_stats() {
        use crate::gcode::ArcDirection;

        let mut writer = GCodeWriter::new();
        writer.travel_to(10.0, 0.0, None);

        // Quarter circle arc with radius 10
        // Expected arc length ≈ π * 10 / 2 ≈ 15.7
        let initial_travel = writer.stats().travel_distance_mm;
        writer.extrude_arc(
            0.0,
            10.0,
            -10.0,
            0.0,
            1.0,
            ArcDirection::CounterClockwise,
            None,
        );

        let arc_length = writer.stats().travel_distance_mm - initial_travel;
        let expected_length = std::f64::consts::PI * 10.0 / 2.0;
        assert!(
            (arc_length - expected_length).abs() < 0.5,
            "Arc length {} should be close to {}",
            arc_length,
            expected_length
        );
    }
}
