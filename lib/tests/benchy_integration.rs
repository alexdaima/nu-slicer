//! 3DBenchy Integration Tests
//!
//! These tests validate the Rust slicer implementation by comparing its output
//! against reference G-code generated by BambuStudio (Bambu H2D + Bambu PLA Basic).
//!
//! The tests cover:
//! 1. STL loading and mesh validation
//! 2. Layer slicing accuracy
//! 3. G-code generation parity
//! 4. Semantic equivalence of toolpaths

use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

use slicer::gcode::compare::{ComparisonConfig, GCodeComparator, ParsedGCode};
use slicer::mesh::load_stl;
use slicer::pipeline::{PipelineConfig, PrintPipeline};
use slicer::slice::{Slicer, SlicingParams};
use slicer::TriangleMesh;

/// Path to test STL files
fn test_stls_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("data/test_stls")
}

/// Path to reference G-code files
fn reference_gcodes_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("data/reference_gcodes")
}

/// Load the 3DBenchy STL file
fn load_benchy_stl() -> TriangleMesh {
    let stl_path = test_stls_dir().join("3DBenchy.stl");
    load_stl(&stl_path).expect("Failed to load 3DBenchy.stl")
}

/// Load the reference 3DBenchy G-code
fn load_benchy_reference_gcode() -> String {
    let gcode_path = reference_gcodes_dir().join("3DBenchy.gcode");
    fs::read_to_string(&gcode_path).expect("Failed to load 3DBenchy.gcode")
}

/// Parse G-code header settings from BambuStudio format
fn parse_gcode_settings(gcode: &str) -> HashMap<String, String> {
    let mut settings = HashMap::new();

    for line in gcode.lines() {
        let line = line.trim();
        if line.starts_with("; ") && line.contains(" = ") {
            if let Some(pos) = line.find(" = ") {
                let key = line[2..pos].trim().to_string();
                let value = line[pos + 3..].trim().to_string();
                settings.insert(key, value);
            }
        }
    }

    settings
}

/// Extract layer information from reference G-code
#[derive(Debug, Clone)]
struct LayerInfo {
    layer_num: usize,
    z_height: f64,
    line_start: usize,
    line_end: usize,
}

/// Parse layer changes from G-code
fn parse_layer_changes(gcode: &str) -> Vec<LayerInfo> {
    let mut layers = Vec::new();
    let mut current_layer: Option<LayerInfo> = None;
    let mut current_z: f64 = 0.0;
    let mut layer_num: usize = 0;

    for (line_num, line) in gcode.lines().enumerate() {
        let line = line.trim();

        if line == "; CHANGE_LAYER" {
            // End previous layer if exists
            if let Some(mut layer) = current_layer.take() {
                layer.line_end = line_num;
                layers.push(layer);
            }

            layer_num += 1;
            current_layer = Some(LayerInfo {
                layer_num,
                z_height: current_z,
                line_start: line_num,
                line_end: 0,
            });
        } else if line.starts_with("; Z_HEIGHT: ") {
            if let Ok(z) = line[12..].trim().parse::<f64>() {
                current_z = z;
                if let Some(ref mut layer) = current_layer {
                    layer.z_height = z;
                }
            }
        }
    }

    // Close last layer
    if let Some(mut layer) = current_layer {
        layer.line_end = gcode.lines().count();
        layers.push(layer);
    }

    layers
}

/// Extract G-code commands (G0, G1, G2, G3) from a string
#[derive(Debug, Clone, PartialEq)]
struct GCodeMove {
    command: String,
    x: Option<f64>,
    y: Option<f64>,
    z: Option<f64>,
    e: Option<f64>,
    f: Option<f64>,
    i: Option<f64>,
    j: Option<f64>,
}

impl GCodeMove {
    fn parse(line: &str) -> Option<Self> {
        let line = line.trim();

        // Skip comments and empty lines
        if line.is_empty() || line.starts_with(';') {
            return None;
        }

        // Check if it's a move command
        if !line.starts_with("G0")
            && !line.starts_with("G1")
            && !line.starts_with("G2")
            && !line.starts_with("G3")
        {
            return None;
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.is_empty() {
            return None;
        }

        let command = parts[0].to_string();
        let mut mov = GCodeMove {
            command,
            x: None,
            y: None,
            z: None,
            e: None,
            f: None,
            i: None,
            j: None,
        };

        for part in &parts[1..] {
            if part.starts_with(';') {
                break; // End of command, rest is comment
            }

            let (code, value) = part.split_at(1);
            if let Ok(v) = value.parse::<f64>() {
                match code {
                    "X" => mov.x = Some(v),
                    "Y" => mov.y = Some(v),
                    "Z" => mov.z = Some(v),
                    "E" => mov.e = Some(v),
                    "F" => mov.f = Some(v),
                    "I" => mov.i = Some(v),
                    "J" => mov.j = Some(v),
                    _ => {}
                }
            }
        }

        Some(mov)
    }
}

/// Statistics about G-code comparison
#[derive(Debug, Default)]
struct GCodeComparisonStats {
    total_moves: usize,
    matching_moves: usize,
    position_differences: Vec<f64>,
    extrusion_differences: Vec<f64>,
}

// =============================================================================
// TESTS
// =============================================================================

#[test]
fn test_benchy_stl_exists() {
    let stl_path = test_stls_dir().join("3DBenchy.stl");
    assert!(
        stl_path.exists(),
        "3DBenchy.stl not found at {:?}",
        stl_path
    );
}

#[test]
fn test_benchy_reference_gcode_exists() {
    let gcode_path = reference_gcodes_dir().join("3DBenchy.gcode");
    assert!(
        gcode_path.exists(),
        "3DBenchy.gcode not found at {:?}",
        gcode_path
    );
}

#[test]
fn test_benchy_stl_loads_successfully() {
    let mesh = load_benchy_stl();

    // 3DBenchy should have a reasonable number of triangles
    assert!(
        mesh.triangle_count() > 1000,
        "3DBenchy should have many triangles, got {}",
        mesh.triangle_count()
    );

    // Should have vertices
    assert!(
        mesh.vertex_count() > 1000,
        "3DBenchy should have many vertices, got {}",
        mesh.vertex_count()
    );
}

#[test]
fn test_benchy_mesh_bounding_box() {
    let mesh = load_benchy_stl();
    let bb = mesh.compute_bounding_box();

    assert!(bb.is_defined(), "Bounding box should be defined");

    // 3DBenchy is approximately 60mm x 31mm x 48mm
    let size = bb.size();

    // Check dimensions are in reasonable range (allowing for different orientations)
    assert!(
        size.x > 20.0 && size.x < 100.0,
        "X dimension {} out of expected range",
        size.x
    );
    assert!(
        size.y > 20.0 && size.y < 100.0,
        "Y dimension {} out of expected range",
        size.y
    );
    assert!(
        size.z > 30.0 && size.z < 60.0,
        "Z dimension {} out of expected range",
        size.z
    );

    println!(
        "3DBenchy bounding box: {:?} x {:?} x {:?} mm",
        size.x, size.y, size.z
    );
}

#[test]
fn test_benchy_mesh_is_valid() {
    let mesh = load_benchy_stl();

    // All triangles should have valid vertices (checked via triangle_vertices)
    for i in 0..mesh.triangle_count() {
        // This will panic if indices are invalid
        let vertices = mesh.triangle_vertices(i);
        // Vertices should be finite numbers
        for v in &vertices {
            assert!(v.x.is_finite(), "Invalid vertex X coordinate");
            assert!(v.y.is_finite(), "Invalid vertex Y coordinate");
            assert!(v.z.is_finite(), "Invalid vertex Z coordinate");
        }
    }
}

#[test]
fn test_reference_gcode_header_parsing() {
    let gcode = load_benchy_reference_gcode();
    let settings = parse_gcode_settings(&gcode);

    // Check expected settings exist
    assert!(
        settings.contains_key("layer_height"),
        "Should have layer_height setting"
    );
    assert!(
        settings.contains_key("initial_layer_print_height"),
        "Should have initial_layer_print_height setting"
    );
    assert!(
        settings.contains_key("filament_type"),
        "Should have filament_type setting"
    );

    // Validate expected values
    assert_eq!(
        settings.get("layer_height").map(|s| s.as_str()),
        Some("0.2"),
        "Layer height should be 0.2mm"
    );
    assert_eq!(
        settings.get("filament_type").map(|s| s.as_str()),
        Some("PLA"),
        "Filament type should be PLA"
    );

    println!("Parsed {} settings from reference G-code", settings.len());
}

#[test]
fn test_reference_gcode_layer_count() {
    let gcode = load_benchy_reference_gcode();
    let layers = parse_layer_changes(&gcode);

    // According to the header: total layer number: 240
    assert_eq!(layers.len(), 240, "Expected 240 layers based on header");

    // Check layer numbers are sequential
    for (i, layer) in layers.iter().enumerate() {
        assert_eq!(layer.layer_num, i + 1, "Layer numbers should be sequential");
    }

    // Check Z heights are increasing
    for i in 1..layers.len() {
        assert!(
            layers[i].z_height >= layers[i - 1].z_height,
            "Z heights should be non-decreasing: layer {} z={} < layer {} z={}",
            i,
            layers[i].z_height,
            i - 1,
            layers[i - 1].z_height
        );
    }
}

#[test]
fn test_reference_gcode_z_heights() {
    let gcode = load_benchy_reference_gcode();
    let layers = parse_layer_changes(&gcode);

    // First layer should be at 0.2mm (initial_layer_print_height)
    assert!(
        (layers[0].z_height - 0.2).abs() < 0.001,
        "First layer Z height should be 0.2, got {}",
        layers[0].z_height
    );

    // Last layer should be at approximately 48mm (max_z_height from header)
    let last_z = layers.last().unwrap().z_height;
    assert!(
        (last_z - 48.0).abs() < 0.5,
        "Last layer Z should be ~48mm, got {}",
        last_z
    );

    // Layer height should be 0.2mm
    for i in 1..layers.len() {
        let dz = layers[i].z_height - layers[i - 1].z_height;
        // Allow some tolerance for variable layer height
        assert!(
            dz >= 0.0 && dz <= 0.3,
            "Layer height {} at layer {} out of range",
            dz,
            i
        );
    }
}

#[test]
fn test_slicing_produces_correct_layer_count() {
    let mesh = load_benchy_stl();

    // Configure slicer to match reference G-code settings
    let params = SlicingParams {
        first_layer_height: 0.2,
        layer_height: 0.2,
        ..Default::default()
    };

    let slicer = Slicer::new(params);
    let layers = slicer.slice(&mesh).expect("Slicing should succeed");

    // Should produce approximately the same number of layers as reference
    // Allow some tolerance since the implementation might handle boundaries differently
    let expected_layers = 240;
    let tolerance = 5;

    assert!(
        (layers.len() as i32 - expected_layers as i32).abs() <= tolerance,
        "Expected ~{} layers, got {} (tolerance: {})",
        expected_layers,
        layers.len(),
        tolerance
    );

    println!(
        "Slicer produced {} layers (reference: {})",
        layers.len(),
        expected_layers
    );
}

#[test]
fn test_slicing_layer_heights_match_reference() {
    let mesh = load_benchy_stl();
    let reference_gcode = load_benchy_reference_gcode();
    let reference_layers = parse_layer_changes(&reference_gcode);

    let params = SlicingParams {
        first_layer_height: 0.2,
        layer_height: 0.2,
        ..Default::default()
    };

    let slicer = Slicer::new(params);
    let layers = slicer.slice(&mesh).expect("Slicing should succeed");

    // Compare Z heights for overlapping layers
    let min_count = layers.len().min(reference_layers.len());

    let mut max_z_diff = 0.0f64;
    for i in 0..min_count {
        // Use the _mm variant to get floating-point value for comparison
        let our_z = layers[i].top_z_mm();
        let ref_z = reference_layers[i].z_height;
        let diff = (our_z - ref_z).abs();
        max_z_diff = max_z_diff.max(diff);
    }

    // Z heights should be very close
    assert!(
        max_z_diff < 0.1,
        "Maximum Z height difference {} exceeds tolerance",
        max_z_diff
    );

    println!("Maximum Z height difference: {:.4}mm", max_z_diff);
}

#[test]
fn test_slicing_produces_actual_geometry() {
    let mesh = load_benchy_stl();

    let params = SlicingParams {
        first_layer_height: 0.2,
        layer_height: 0.2,
        ..Default::default()
    };

    let slicer = Slicer::new(params);
    let layers = slicer.slice(&mesh).expect("Slicing should succeed");

    // Count layers that have actual geometry (ExPolygons with contours)
    let layers_with_geometry: Vec<_> = layers
        .iter()
        .enumerate()
        .filter(|(_, l)| l.regions().iter().any(|r| !r.slices().is_empty()))
        .collect();

    println!(
        "Layers with geometry: {}/{}",
        layers_with_geometry.len(),
        layers.len()
    );

    // All layers should have geometry since 3DBenchy is a solid object
    assert!(
        layers_with_geometry.len() > layers.len() * 9 / 10,
        "Expected >90% of layers to have geometry, got {}/{}",
        layers_with_geometry.len(),
        layers.len()
    );

    // Check that some layers have meaningful contours
    let mut total_contours = 0;
    let mut total_holes = 0;
    for layer in &layers {
        for region in layer.regions() {
            for expoly in region.slices() {
                total_contours += 1;
                total_holes += expoly.holes.len();
            }
        }
    }

    println!(
        "Total contours: {}, Total holes: {}",
        total_contours, total_holes
    );

    // 3DBenchy should produce many contours across all layers
    assert!(
        total_contours > 200,
        "Expected many contours, got {}",
        total_contours
    );

    // 3DBenchy has internal cavities that should produce holes
    assert!(
        total_holes > 0,
        "Expected some holes (3DBenchy has internal cavities)"
    );
}

#[test]
fn test_gcode_move_parsing() {
    // Test the G-code move parser with various formats
    let line1 = "G1 X100.5 Y200.3 E0.5 F3000";
    let mov1 = GCodeMove::parse(line1).expect("Should parse G1 move");
    assert_eq!(mov1.command, "G1");
    assert_eq!(mov1.x, Some(100.5));
    assert_eq!(mov1.y, Some(200.3));
    assert_eq!(mov1.e, Some(0.5));
    assert_eq!(mov1.f, Some(3000.0));

    let line2 = "G2 X10 Y20 I5 J-5 E0.1";
    let mov2 = GCodeMove::parse(line2).expect("Should parse G2 arc");
    assert_eq!(mov2.command, "G2");
    assert_eq!(mov2.i, Some(5.0));
    assert_eq!(mov2.j, Some(-5.0));

    let comment = "; CHANGE_LAYER";
    assert!(GCodeMove::parse(comment).is_none(), "Should skip comments");

    let empty = "";
    assert!(GCodeMove::parse(empty).is_none(), "Should skip empty lines");
}

#[test]
fn test_reference_gcode_has_valid_moves() {
    let gcode = load_benchy_reference_gcode();

    let mut move_count = 0;
    let mut extrusion_moves = 0;
    let mut travel_moves = 0;
    let mut arc_moves = 0;

    for line in gcode.lines() {
        if let Some(mov) = GCodeMove::parse(line) {
            move_count += 1;

            if mov.e.map(|e| e > 0.0).unwrap_or(false) {
                extrusion_moves += 1;
            } else if mov.e.is_none() && (mov.x.is_some() || mov.y.is_some()) {
                travel_moves += 1;
            }

            if mov.command == "G2" || mov.command == "G3" {
                arc_moves += 1;
            }
        }
    }

    println!("Reference G-code statistics:");
    println!("  Total moves: {}", move_count);
    println!("  Extrusion moves: {}", extrusion_moves);
    println!("  Travel moves: {}", travel_moves);
    println!("  Arc moves: {}", arc_moves);

    assert!(move_count > 10000, "Should have many moves");
    assert!(extrusion_moves > 5000, "Should have many extrusion moves");
}

/// Test that we can successfully iterate through the entire reference G-code
#[test]
fn test_reference_gcode_complete_parse() {
    let gcode = load_benchy_reference_gcode();
    let lines: Vec<&str> = gcode.lines().collect();

    assert!(
        lines.len() > 100000,
        "Reference G-code should have many lines, got {}",
        lines.len()
    );

    // Count different line types
    let mut comment_lines = 0;
    let mut gcode_lines = 0;
    let mut empty_lines = 0;
    let mut other_lines = 0;

    for line in &lines {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            empty_lines += 1;
        } else if trimmed.starts_with(';') {
            comment_lines += 1;
        } else if trimmed.starts_with('G') || trimmed.starts_with('M') || trimmed.starts_with('T') {
            gcode_lines += 1;
        } else {
            other_lines += 1;
        }
    }

    println!("Reference G-code line breakdown:");
    println!("  Total lines: {}", lines.len());
    println!("  G/M/T codes: {}", gcode_lines);
    println!("  Comments: {}", comment_lines);
    println!("  Empty: {}", empty_lines);
    println!("  Other: {}", other_lines);
}

// =============================================================================
// PIPELINE INTEGRATION TESTS
// =============================================================================

#[test]
fn test_pipeline_generates_gcode_for_benchy() {
    let mesh = load_benchy_stl();

    // Configure pipeline similar to reference settings
    let config = PipelineConfig::new()
        .layer_height(0.2)
        .first_layer_height(0.2)
        .perimeters(3)
        .infill_density(0.15)
        .nozzle_diameter(0.4);

    let mut pipeline = PrintPipeline::new(config);
    let result = pipeline.process(&mesh);

    assert!(
        result.is_ok(),
        "Pipeline should process benchy: {:?}",
        result
    );

    let gcode = result.unwrap();
    assert!(!gcode.is_empty(), "G-code should not be empty");

    // Basic sanity checks
    let content = gcode.content();
    assert!(content.contains("G1"), "G-code should have extrusion moves");
    assert!(
        content.contains("Layer"),
        "G-code should have layer comments"
    );
    assert!(content.contains("G28"), "G-code should have homing");
    assert!(
        content.contains("M104") || content.contains("M109"),
        "G-code should set temperature"
    );
}

#[test]
fn test_pipeline_layer_count_reasonable() {
    let mesh = load_benchy_stl();
    let reference_gcode = load_benchy_reference_gcode();

    // Get reference layer count
    let ref_layers = parse_layer_changes(&reference_gcode);
    let ref_layer_count = ref_layers.len();

    // Generate with same layer height
    let config = PipelineConfig::new()
        .layer_height(0.2)
        .first_layer_height(0.2)
        .perimeters(3)
        .infill_density(0.15);

    let mut pipeline = PrintPipeline::new(config);
    let gcode = pipeline.process(&mesh).expect("Pipeline should succeed");

    // Count layers in generated G-code
    let generated_layer_count = gcode
        .content()
        .lines()
        .filter(|line| line.contains("; Layer "))
        .count();

    // Should have a similar number of layers (within 10%)
    let tolerance = (ref_layer_count as f64 * 0.1).ceil() as usize;
    let diff = (generated_layer_count as i64 - ref_layer_count as i64).unsigned_abs() as usize;

    assert!(
        diff <= tolerance,
        "Layer count should be within 10%: generated={}, reference={}, diff={}",
        generated_layer_count,
        ref_layer_count,
        diff
    );
}

#[test]
fn test_pipeline_extrusion_reasonable() {
    let mesh = load_benchy_stl();

    let config = PipelineConfig::new()
        .layer_height(0.2)
        .first_layer_height(0.2)
        .perimeters(3)
        .infill_density(0.15);

    let mut pipeline = PrintPipeline::new(config);
    let gcode = pipeline.process(&mesh).expect("Pipeline should succeed");

    // Count extrusion moves and calculate total E
    let mut total_e = 0.0f64;
    let mut last_e = 0.0f64;

    for line in gcode.content().lines() {
        if line.starts_with("G1") && line.contains(" E") {
            if let Some(e_value) = extract_e_value(line) {
                // Absolute extrusion mode
                if e_value > last_e {
                    total_e += e_value - last_e;
                }
                last_e = e_value;
            }
        } else if line.starts_with("G92") && line.contains("E0") {
            last_e = 0.0;
        }
    }

    // Reference shows ~3869mm filament
    // We should be in a reasonable range (say 1000-10000mm)
    assert!(
        total_e > 1000.0,
        "Total extrusion should be > 1000mm, got {}",
        total_e
    );
    assert!(
        total_e < 20000.0,
        "Total extrusion should be < 20000mm, got {}",
        total_e
    );
}

/// Extract E value from a G-code line
fn extract_e_value(line: &str) -> Option<f64> {
    for part in line.split_whitespace() {
        if part.starts_with('E') {
            return part[1..].parse().ok();
        }
    }
    None
}

#[test]
fn test_pipeline_gcode_stats() {
    let mesh = load_benchy_stl();

    let config = PipelineConfig::new()
        .layer_height(0.2)
        .perimeters(3)
        .infill_density(0.15);

    let mut pipeline = PrintPipeline::new(config);
    let gcode = pipeline.process(&mesh).expect("Pipeline should succeed");

    let stats = &gcode.stats;
    assert!(
        stats.layer_count > 100,
        "Should have >100 layers for benchy"
    );
    assert!(
        stats.extrusion_distance_mm > 0.0,
        "Should have extrusion distance"
    );
}

// FUTURE TESTS - Comparison against reference
// =============================================================================

#[test]
#[ignore = "Requires closer parity with BambuStudio output"]
fn test_generated_gcode_layer_count_matches() {
    // This test will compare the number of layers in generated G-code
    // vs the reference G-code exactly
    let mesh = load_benchy_stl();
    let reference_gcode = load_benchy_reference_gcode();
    let ref_layers = parse_layer_changes(&reference_gcode);

    let config = PipelineConfig::new()
        .layer_height(0.2)
        .first_layer_height(0.2)
        .perimeters(3)
        .infill_density(0.15);

    let mut pipeline = PrintPipeline::new(config);
    let gcode = pipeline.process(&mesh).expect("Pipeline should succeed");

    let generated_layer_count = gcode
        .content()
        .lines()
        .filter(|line| line.contains("; Layer "))
        .count();

    assert_eq!(
        generated_layer_count,
        ref_layers.len(),
        "Layer count should match exactly"
    );
}

#[test]
#[ignore = "Requires closer parity with BambuStudio output"]
fn test_generated_gcode_total_extrusion_matches() {
    // This test will compare total extrusion amounts
    // The reference shows: total filament length [mm] : 3869.22
    let _mesh = load_benchy_stl();
    let _reference_gcode = load_benchy_reference_gcode();
    todo!("Implement when aiming for closer extrusion parity")
}

#[test]
#[ignore = "Requires closer parity with BambuStudio output"]
fn test_generated_gcode_print_time_estimate() {
    // This test will compare estimated print times
    // The reference shows: model printing time: 33m 26s
    let _mesh = load_benchy_stl();
    todo!("Implement when print time estimation is added")
}

#[test]
fn test_toolpath_semantic_equivalence() {
    // This test compares toolpaths semantically using the GCodeComparator
    let mesh = load_benchy_stl();
    let reference_gcode = load_benchy_reference_gcode();

    // Generate G-code using our pipeline
    let config = PipelineConfig::default();
    let mut pipeline = PrintPipeline::new(config);
    let gcode = pipeline.process(&mesh).expect("Pipeline should succeed");
    let generated_gcode = gcode.content();

    // Parse both G-codes
    let ref_parsed = ParsedGCode::from_string(&reference_gcode);
    let gen_parsed = ParsedGCode::from_string(&generated_gcode);

    // Use relaxed comparison settings since we're not at full parity yet
    let comparison_config = ComparisonConfig::relaxed();
    let comparator = GCodeComparator::new(comparison_config);
    let comparison = comparator.compare(&ref_parsed, &gen_parsed);

    println!("\n{}", comparison.summary());

    // Use stats from our generated gcode for layer count (more reliable than parser detection)
    let gen_layer_count = gcode.stats.layer_count;
    let ref_layer_count = 240; // Known from reference gcode (;LAYER_COUNT:240)

    let layer_count_diff_percent = ((gen_layer_count as i32 - ref_layer_count as i32).abs() as f64
        / ref_layer_count as f64)
        * 100.0;
    println!(
        "Layer count (from stats): {} vs {} ({:.1}% diff)",
        ref_layer_count, gen_layer_count, layer_count_diff_percent
    );
    // Allow up to 5% difference in layer count
    assert!(
        layer_count_diff_percent < 5.0,
        "Layer count differs by more than 5%: {} vs {}",
        ref_layer_count,
        gen_layer_count
    );

    // Check total moves are in reasonable range
    println!(
        "Total moves: {} (ref) vs {} (gen)",
        comparison.ref_total_moves, comparison.gen_total_moves
    );

    // Check generated gcode has substantial content
    assert!(
        comparison.gen_total_moves > 100000,
        "Generated gcode should have substantial moves"
    );

    // Report overall match percentage (informational, not a hard requirement yet)
    // We don't assert on match percentage since our algorithms differ from reference
    println!(
        "Overall semantic match: {:.1}% (informational only)",
        comparison.match_percentage()
    );
}

#[test]
#[ignore = "Requires full implementation for byte-level comparison"]
fn test_gcode_byte_level_parity() {
    // Ultimate goal: byte-for-byte identical G-code
    // This is very challenging due to floating-point formatting,
    // non-deterministic ordering, etc.
    let _mesh = load_benchy_stl();
    let _reference_gcode = load_benchy_reference_gcode();
    todo!("Implement when aiming for exact parity")
}

// =============================================================================
// BENCHMARK/METRICS TESTS
// =============================================================================

#[test]
fn test_slicing_performance() {
    use std::time::Instant;

    let mesh = load_benchy_stl();
    let params = SlicingParams {
        first_layer_height: 0.2,
        layer_height: 0.2,
        ..Default::default()
    };

    let slicer = Slicer::new(params);

    let start = Instant::now();
    let _layers = slicer.slice(&mesh).expect("Slicing should succeed");
    let elapsed = start.elapsed();

    println!("Slicing time: {:?}", elapsed);

    // Should complete in reasonable time (adjust as implementation matures)
    assert!(
        elapsed.as_secs() < 30,
        "Slicing took too long: {:?}",
        elapsed
    );
}

// =============================================================================
// HELPER FUNCTIONS FOR FUTURE COMPARISON TESTS
// =============================================================================

/// Calculate the total extrusion from G-code
#[allow(dead_code)]
fn calculate_total_extrusion(gcode: &str) -> f64 {
    let mut total_positive = 0.0;

    for line in gcode.lines() {
        if let Some(mov) = GCodeMove::parse(line) {
            if let Some(e) = mov.e {
                if e > 0.0 {
                    total_positive += e;
                }
            }
        }
    }

    total_positive
}

/// Extract feature sections from G-code (e.g., "Outer wall", "Inner wall", "Infill")
#[allow(dead_code)]
fn extract_features(gcode: &str) -> HashMap<String, usize> {
    let mut features = HashMap::new();
    let mut current_feature = String::from("Unknown");

    for line in gcode.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("; FEATURE: ") {
            current_feature = trimmed[11..].to_string();
        } else if GCodeMove::parse(trimmed).is_some() {
            *features.entry(current_feature.clone()).or_insert(0) += 1;
        }
    }

    features
}
